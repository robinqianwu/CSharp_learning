C Sharp 的一些知识点

1. 不要用 == 来判断 double / float 的小数计算结果，例如0.1+0.2 == 0.3 ? 会返回false。
   因为小数在二进制数表示时，分母是不能被 2^n 来表示的数字时，它是无限循环二进制数。
   例如0.1 = 1 / 10, 10 无法被2^n 来表示。所以他们和的计算结果是一个无线循环二进制数，不是0.3
   double 是二进制浮点数（IEEE 754 标准，64 位）
		十进制小数 0.1 和 0.2 在二进制里是 无限循环小数：
		0.1 ≈ 0.00011001100110011…
		0.2 ≈ 0.0011001100110011…

	存储时只能截断近似 → 运算累积微小误差 → 结果不是精确的 0.3，而是 0.30000000000000004  
   
   如果要用来计算精确的小数结果，最后使用decimal，但是其是一个16 Bytes数，占用内存，且速度及表示数字的范围没有double块及大。

	double / float 小数不要直接用 == 比较
	使用 允许误差的比较方法
	对于财务、货币或必须精确比较的场景 → 使用 decimal

2. 尽量不要使用ArrayList，而是使用List，因为List只接受定义了的类型变量，而ArrayList什么类型的变量都接受。
	例如 12，"hello", 1.2等

3. 在逻辑判断中，"或者"用符号 "|" 表示，而不是 "||"

4. 类继承表示为: class ChildClass : ParentClass {}

5. 类继承中，声明子类的话
	public ChlidClass(p1, p2, p3) : base(p1, p2) {this.p3 = p3} 
	
6. Structure vs. Class
	1. 值类型 vs. 引用类型
	结构 (struct)
		值类型，分配在 栈 (stack) 上（除非在堆对象中作为字段）。
		赋值时是 复制整个对象。
		超出作用域会立即销毁。
	类 (class)
		引用类型，分配在 堆 (heap) 上。
		赋值时是 复制引用，多个变量可能指向同一个对象。
		由 GC (垃圾回收器) 管理生命周期。

	2. 内存分配和性能
	结构 (struct)
		适合小型、数据量少的对象（如二维坐标 Point，复数 Complex）。
		在栈上分配和销毁，性能高，不需要 GC。
		但在复制时会整体复制，可能影响性能（如果数据量很大）。
	类 (class)
		适合复杂、需要继承或多态的对象。
		在堆上分配，由 GC 管理。
		引用传递性能更优，适合大对象。
	
	Example:
	Structure Point	
		Point p1 = new Point(1, 2);
		Point p2 = p1;   // 值复制
		p2.X = 5;
		Console.WriteLine(p1.X); // 输出 1，不受影响
		
	Class Person
		Person person1 = new Person("Tom", 20);
		Person person2 = person1;  // 引用复制
		person2.Name = "Jerry";
		Console.WriteLine(person1.Name); // 输出 Jerry，同一个对象

7. Class Attribute的一些写法
	public class Person	{
		// 公开读取，但只能在类内部修改
		public string Name { get; private set; }
		// 只能类内读取，外部可以写（几乎不用，容易误用）
		public int Age { private get; set; }
	}
	默认情况下，属性的 get 和 set 的访问级别 = 属性的访问级别。
	
8. delegate, new DatenType in C#
	什么是 delegate
	delegate 是一种类型，用来 存放方法的引用。
	可以把方法当作变量一样传递、保存、调用。
	用于 回调机制、事件处理、解耦代码。

	✅ 基本示例
	// 声明一个 delegate 类型，返回 int，接收两个 int
	public delegate int MyDelegate(int a, int b);
	class Program
	{
		// 定义两个方法
		static int Add(int x, int y) => x + y;
		static int Multiply(int x, int y) => x * y;

		static void Main()
		{
			// 用 delegate 指向不同的方法
			MyDelegate d1 = Add;
			MyDelegate d2 = Multiply;

			Console.WriteLine(d1(2, 3)); // 输出 5
			Console.WriteLine(d2(2, 3)); // 输出 6
		}
	}
	🔎 特点
	类型安全
	delegate 的签名（参数 & 返回类型）必须和目标方法一致。
	比 C/C++ 的函数指针更安全。
	多播委托 (Multicast Delegate)
	一个 delegate 可以同时引用多个方法。
	调用时会依次执行。

	MyDelegate d = Add;
	d += Multiply;  // 追加方法
	d(2, 3);        // 先调用 Add，再调用 Multiply


	和事件 (event) 密切相关
	C# 的事件就是基于 delegate 封装的。
	你在 WinForms/WPF/ASP.NET 里写的 button.Click += Handler 背后就是 delegate。

	✅ 常见用法
	1. 回调 (Callback)
	void DoWork(MyDelegate callback)
	{
		Console.WriteLine("Working...");
		int result = callback(5, 10); // 调用回调
		Console.WriteLine("Result: " + result);
	}

	DoWork(Add);      // 传入方法
	DoWork(Multiply); // 传入方法

	2. 匿名方法 + Lambda
	C# 2.0 以后，不用每次都写 delegate 声明方法，可以用 匿名方法 或 Lambda 表达式：

	MyDelegate d = delegate(int x, int y) { return x - y; };
	MyDelegate d2 = (x, y) => x / y;

	3. 内置泛型委托
	C# 提供了常用的委托类型，不用每次都自己写：

	Action<T> → 没有返回值的方法
	Func<T, TResult> → 有返回值的方法
	Predicate<T> → 返回 bool 的方法

	Action<string> printer = s => Console.WriteLine(s);
	printer("Hello");

	Func<int, int, int> adder = (a, b) => a + b;
	Console.WriteLine(adder(2, 3));

	Predicate<int> isEven = x => x % 2 == 0;
	Console.WriteLine(isEven(4)); // true

	📌 总结

	delegate 是 方法的引用类型。
	让方法可以 作为参数传递，实现 回调、事件、多播 等功能。
	现代 C# 中，更多使用 lambda + Action/Func/Predicate，写法更简洁。

9. 特性 (Attribute) 的一种，叫 Obsolete，用于 标记某个方法、类、属性等为过时
	public class MyClass
	{
		[Obsolete("Use NewMethod instead")]
		public void OldMethod()
		{
			Console.WriteLine("Old method");
		}

		public void NewMethod()
		{
			Console.WriteLine("New method");
		}
	}
	
	调用示例：
		var obj = new MyClass();
		obj.OldMethod(); // ⚠ 编译器提示：Use NewMethod instead
		obj.NewMethod(); // ✅ 正常调用

10. 🔹 C# 命名约定（简化版）
	元素						约定									示例
	类 / 接口 / 枚举 / 结构体	PascalCase（大写开头，每个单词首字母大写）	Customer, OrderDetail, ILogger
	方法						PascalCase								GetUserName(), CalculateTotal()
	属性						PascalCase								FirstName, IsActive
	字段（私有变量）			camelCase（小写开头）或 _camelCase（推荐）	_count, _connectionString
	局部变量 / 方法参数			camelCase								 int totalCount, string userName
	常量 / readonly static 字段	PascalCase								MaxItems, DefaultTimeout
	命名空间					PascalCase								MyApp.DataAccess

11. C# Controller🔹 命名规则
	必须以 Controller 结尾
		框架会通过反射自动识别哪些类是 Controller。
		例如：HomeController, UserController, OrderController。
		如果你写成 HomeCtrl，ASP.NET Core 默认就不会把它当成 Controller。
	使用 PascalCase（大写开头，每个单词首字母大写）
		例如：ProductController ✅
		不要写成 productcontroller ❌
	一个 Controller 对应一个资源或业务领域
		UserController → 处理用户相关 API
		ProductController → 处理产品相关 API
		不建议写成 UtilsController 这种大杂烩。
	Controller 内的方法（Action）
		方法名用 PascalCase
			例如：GetAll(), Create(), Update(), Delete()
		常见 REST 风格：
			GET /users → UserController.GetAll()
			GET /users/{id} → UserController.GetById(int id)
			POST /users → UserController.Create(User user)

11. "ASPNETCORE_ENVIRONMENT": "Development" or "Staging" or "Production"